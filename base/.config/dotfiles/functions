# enforce argc and display usage when violated.
usage () {
    if [ "$1" -lt "$2" ]; then
        >&2 cat <<EOF
${3}
usage: ${4}
EOF
        return 1
    fi
}

die () { printf %s\\n "$1"; return 1; }

require () {
    df_require "$1" || die "${1} is required, but not found"
}

wscan () {
    require iw || return $?
    usage $# 1 'uses INTERFACE to scan for wireless AP SSIDs.' \
        "$0 INTERFACE" || return $?
    sudo iw dev "$1" scan | grep 'SSID:' | awk '{if ($2) print $2;}'
}

# NOTE: ip addr is better than this, for example you can see the ip assigned to a particular interface,
#       whereas hostname -i just prints the ips
lanip () {
    require hostname || return $?
    printf %s\\n "$(hostname -i)"
}

wanip () {
    require dig || return $?
    printf %s\\n "$(dig @resolver1.opendns.com ANY myip.opendns.com +short)"
}

sshnew () {
    require ssh-keygen || return $?
    usage $# 1 'Generates a secure ssh keypair (openssh format) using ed25519.' \
        "$0 [keypair name] [optional comment]" || return $?
    ssh-keygen -t ed25519 -a 100 -f "${HOME}/.ssh/${1}" -N '' -C "$2"
    chmod 400 -v "${HOME}/.ssh/${1}"
    chmod 444 -v "${HOME}/.ssh/${1}.pub"
}

sshnewrsa () {
    require ssh-keygen || return $?
    usage $# 1 'Generates a secure ssh keypair (openssh format) using rsa-4096.' \
        "$0 [keypair name] [optional comment]" || return $?
    ssh-keygen -t rsa -b 4096 -a 100 -f "${HOME}/.ssh/${1}" -N '' -C "$2"
    chmod 400 -v "${HOME}/.ssh/${1}"
    chmod 444 -v "${HOME}/.ssh/${1}.pub"
}

# this is extremely naive, will probably remove after i'm more experienced with making patches
mkpatch () {
    require diff || return $?
    usage $# 1 'Opens FILE with your EDITOR and generates a same-file patch without timestamp.' \
        "$0 FILE" || return $?
    [ -z "$EDITOR" ] && die '$EDITOR is not set.'
    tmp="$(mktemp)" || die 'mktemp failed'
    cp "$1" "$tmp"
    $EDITOR "$tmp"
    diff -ua "$1" "$tmp" | sed "s|${tmp}|${1}|" | awk '{ if (NR==1 || NR==2) { print $1,$2 } else { print } };' > "${1}.patch"
    rm "$tmp"
}

# extension counter
ecount () {
    require fd || return $?
    fd -tf -x echo {/} | awk -F. 'NF > 1 {print tolower($NF)}' | sort | uniq -c | sort -n
}

esize () {
    require fd || return $?
    usage $# 1 'Reports total disk space taken up by files with the extension, in the current directory.' \
        "$0 extension" || return $?
    fd -e "$1" -0 | xargs -0 du -hc | awk 'END { print $1 }'
}

mdl () {
    require youtube-dl || return $?
    require ffmpeg || return $?
    usage $# 1 'youtube-dl + ffmpeg (opus 96k reencode) music downloader' \
        "$0 music-url" || return $?
    youtube-dl --ignore-config --no-playlist \
        -x --audio-format best \
        --postprocessor-args '-c:a libopus -b:a 96K' \
        --add-metadata \
        -o "%(title)s [%(id)s].%(ext)s" "$1"
}

vdl () {
    require youtube-dl || return $?
    require ffmpeg || return $?
    usage $# 1 'youtube-dl + ffmpeg (hevc fast crf 30, opus 96k reencode into mkv) video downloader' \
        "$0 music-url" || return $?
    youtube-dl --ignore-config --no-playlist \
        -f bestvideo+bestaudio \
        --postprocessor-args '-c:v hevc -preset fast -crf 30 -c:a libopus -b:a 96K' \
        --add-metadata \
        --merge-output-format mkv \
        -o "%(title)s [%(id)s].%(ext)s" "$1"
}
